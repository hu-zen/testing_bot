//=============================Motor Controll with Intelligent Deceleration===============================
// Versi Final - Berdasarkan kode asli yang stabil, dengan penambahan deselerasi non-blocking HANYA saat berhenti.
//======================================================================================================

#include <Servo.h>
#include <HB25MotorControl.h>
#include <ros.h>
#include <geometry_msgs/Twist.h>

const byte controlPinL = 6;
const byte controlPinR = 7;

HB25MotorControl motorControlL(controlPinL);
HB25MotorControl motorControlR(controlPinR);

ros::NodeHandle nh;

// --- Variabel untuk kontrol kecepatan ---
int target_left_speed = 0;   // Kecepatan target dari ROS
int target_right_speed = 0;
int current_left_speed = 0;  // Kecepatan aktual yang dikirim ke motor
int current_right_speed = 0;

// --- Variabel untuk timing deselerasi non-blocking ---
unsigned long lastStopTime = 0;
// --- BAGIAN KALIBRASI (UBAH NILAI DI SINI) ---
// Seberapa sering (dalam milidetik) kecepatan diturunkan saat berhenti.
// Angka lebih kecil = deselerasi lebih halus & lambat.
const int stop_interval = 10; 

// --- Callback Function ---
// Hanya menyimpan kecepatan target dari ROS, tidak ada logika gerak di sini.
void twistCallback(const geometry_msgs::Twist& twist_msg) {
  int linear_speed = (int)(twist_msg.linear.x * 300);
  int angular_speed = (int)(twist_msg.angular.z * 300);
  
  target_left_speed = linear_speed - angular_speed;
  target_right_speed = linear_speed + angular_speed;

  target_left_speed = constrain(target_left_speed, -500, 500);
  target_right_speed = constrain(target_right_speed, -500, 500);
}

ros::Subscriber<geometry_msgs::Twist> sub("cmd_vel", &twistCallback);

void setup() {
  nh.getHardware()->setBaud(115200);
  nh.initNode();
  nh.subscribe(sub);

  motorControlL.begin();
  motorControlR.begin();
}

void loop() {
  // Selalu cek pesan baru dari ROS
  nh.spinOnce();

  // --- LOGIKA UTAMA YANG DIPERBAIKI ---

  // Jika target kecepatan BUKAN 0 (robot diperintahkan untuk bergerak)...
  if (target_left_speed != 0 || target_right_speed != 0) {
    // Jalankan perintah secara LANGSUNG, sama seperti program asli Anda.
    // Ini menjaga responsivitas joystick dan menghilangkan gerakan tersendat.
    motorControlL.moveAtSpeed(target_left_speed);
    motorControlR.moveAtSpeed(target_right_speed);
    
    // Simpan kecepatan saat ini untuk digunakan saat deselerasi nanti.
    current_left_speed = target_left_speed;
    current_right_speed = target_right_speed;
  } else {
    // JIKA target kecepatan ADALAH 0 (robot diperintahkan berhenti)...
    // Jalankan logika deselerasi non-blocking.
    unsigned long currentTime = millis();
    if (currentTime - lastStopTime >= stop_interval) {
      lastStopTime = currentTime;
      
      // Turunkan kecepatan kiri menuju 0 secara bertahap
      if (current_left_speed > 0) current_left_speed--;
      if (current_left_speed < 0) current_left_speed++;
      
      // Turunkan kecepatan kanan menuju 0 secara bertahap
      if (current_right_speed > 0) current_right_speed--;
      if (current_right_speed < 0) current_right_speed++;
      
      // Kirim kecepatan yang sudah diturunkan ke motor
      motorControlL.moveAtSpeed(current_left_speed);
      motorControlR.moveAtSpeed(current_right_speed);
    }
  }
}
