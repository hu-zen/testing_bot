//=============================Motor Controll with Switchable Modes===============================
// Versi 7.0 - Menggabungkan mode "hb25_rosserial" (Before) dan "control_pwm" (After)
// Mode dapat diganti secara real-time melalui Serial Monitor.
//==============================================================================================

#include <Servo.h>
#include <HB25MotorControl.h>
#include <ros.h>
#include <geometry_msgs/Twist.h>

//===========================================================================================
// --- PENGATURAN PROGRAM ---
//===========================================================================================
// Mode Awal saat Arduino dinyalakan: 0=STOP, 1=BEFORE, 2=AFTER
int control_mode = 0; 
//===========================================================================================

const byte controlPinL = 6;
const byte controlPinR = 7;

HB25MotorControl motorControlL(controlPinL);
HB25MotorControl motorControlR(controlPinR);

ros::NodeHandle nh;

// --- Variabel untuk kontrol kecepatan ---
int target_left_speed = 0;
int target_right_speed = 0;
int current_left_speed = 0;
int current_right_speed = 0;

// --- Variabel untuk timing mode "After" ---
unsigned long lastUpdateTime = 0;
const int update_interval = 10;
const int speed_step = 2;


// --- Callback Function untuk menerima perintah dari ROS ---
void twistCallback(const geometry_msgs::Twist& twist_msg) {
  int linear_speed = (int)(twist_msg.linear.x * 300);
  int angular_speed = (int)(twist_msg.angular.z * 300);
  
  target_left_speed = linear_speed - angular_speed;
  target_right_speed = linear_speed + angular_speed;

  target_left_speed = constrain(target_left_speed, -500, 500);
  target_right_speed = constrain(target_right_speed, -500, 500);
}

ros::Subscriber<geometry_msgs::Twist> sub("cmd_vel", &twistCallback);

void setup() {
  nh.getHardware()->setBaud(115200);
  nh.initNode();
  nh.subscribe(sub);

  motorControlL.begin();
  motorControlR.begin();

  // Aktifkan juga Serial Monitor untuk menerima perintah mode
  Serial.begin(9600);
  Serial.println("Mode controller ready. Type 'before', 'after', or 'stop'.");
}

void loop() {
  // Selalu cek pesan dari ROS
  nh.spinOnce();

  // --- LOGIKA PEMILIHAN MODE ---
  // Cek apakah ada perintah baru dari Serial Monitor
  if (Serial.available() > 0) {
    String command = Serial.readStringUntil('\n');
    command.trim();
    
    if (command.equalsIgnoreCase("before")) {
      control_mode = 1;
      Serial.println("Mode switched to: BEFORE (Instant Stop)");
    } else if (command.equalsIgnoreCase("after")) {
      control_mode = 2;
      Serial.println("Mode switched to: AFTER (Smooth Motion)");
    } else if (command.equalsIgnoreCase("stop")) {
      control_mode = 0;
      Serial.println("Mode switched to: STOP (Motors Disabled)");
    }
  }

  // --- EKSEKUSI BERDASARKAN MODE YANG AKTIF ---
  
  // MODE 1: "BEFORE" (hb25_rosserial - Berhenti Instan)
  if (control_mode == 1) {
    motorControlL.moveAtSpeed(target_left_speed);
    motorControlR.moveAtSpeed(target_right_speed);
  }
  // MODE 2: "AFTER" (control_pwm - Gerakan Halus)
  else if (control_mode == 2) {
    unsigned long currentTime = millis();
    if (currentTime - lastUpdateTime >= update_interval) {
      lastUpdateTime = currentTime;
      
      if (current_left_speed < target_left_speed) current_left_speed = min(current_left_speed + speed_step, target_left_speed);
      else if (current_left_speed > target_left_speed) current_left_speed = max(current_left_speed - speed_step, target_left_speed);
      
      if (current_right_speed < target_right_speed) current_right_speed = min(current_right_speed + speed_step, target_right_speed);
      else if (current_right_speed > target_right_speed) current_right_speed = max(current_right_speed - speed_step, target_right_speed);
      
      motorControlL.moveAtSpeed(current_left_speed);
      motorControlR.moveAtSpeed(current_right_speed);
    }
  }
  // MODE 0: "STOP" (Kondisi Kosong/Transisi)
  else {
    motorControlL.moveAtSpeed(0);
    motorControlR.moveAtSpeed(0);
    current_left_speed = 0;
    current_right_speed = 0;
  }
}
