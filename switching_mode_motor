//=============================Motor Controll with Switchable Modes (Serial Monitor)======================
// Versi 7.3 - Final, Lengkap, dan Terkoreksi.
// - Menggabungkan mode 'Before' (hb25_rosserial) dan 'After' (control_pwm).
// - Mode diganti via Serial Monitor.
// - Menggunakan SATU baud rate konsisten (115200) untuk semua komunikasi.
//====================================================================================================

#include <Servo.h>
#include <HB25MotorControl.h>
#include <ros.h>
#include <geometry_msgs/Twist.h>

//===========================================================================================
// --- PENGATURAN PROGRAM ---
//===========================================================================================
// Mode Awal saat Arduino dinyalakan: 0=STOP, 1=BEFORE, 2=AFTER
int control_mode = 0; 
//===========================================================================================

// --- DEKLARASI MOTOR (PENTING: Harus di sini, di lingkup global) ---
const byte controlPinL = 6;
const byte controlPinR = 7;
HB25MotorControl motorControlL(controlPinL);
HB25MotorControl motorControlR(controlPinR);
// -----------------------------------------------------------------

ros::NodeHandle nh;

// --- Variabel untuk kontrol kecepatan ---
int target_left_speed = 0;
int target_right_speed = 0;
int current_left_speed = 0; // Hanya digunakan oleh mode "After"
int current_right_speed = 0; // Hanya digunakan oleh mode "After"

// --- Variabel untuk timing mode "After" ---
unsigned long lastUpdateTime = 0;
const int update_interval = 10;
const int speed_step = 2;


// --- Callback Function untuk menerima perintah dari ROS ---
void twistCallback(const geometry_msgs::Twist& twist_msg) {
  int linear_speed = (int)(twist_msg.linear.x * 300);
  int angular_speed = (int)(twist_msg.angular.z * 300);
  
  target_left_speed = linear_speed - angular_speed;
  target_right_speed = linear_speed + angular_speed;

  target_left_speed = constrain(target_left_speed, -500, 500);
  target_right_speed = constrain(target_right_speed, -500, 500);
}

ros::Subscriber<geometry_msgs::Twist> sub("cmd_vel", &twistCallback);

void setup() {
  // Gunakan satu baud rate untuk semua komunikasi.
  // rosserial akan menggunakan port serial yang sama yang dibuka oleh Serial.begin()
  Serial.begin(115200);
  nh.initNode();
  nh.subscribe(sub);

  motorControlL.begin();
  motorControlR.begin();
  
  Serial.println("Mode controller ready. Type 'before', 'after', or 'stop'.");
}

void loop() {
  // Selalu cek pesan dari ROS
  nh.spinOnce();

  // --- LOGIKA PEMILIHAN MODE DARI SERIAL MONITOR ---
  if (Serial.available() > 0) {
    String command = Serial.readStringUntil('\n');
    command.trim();
    
    if (command.equalsIgnoreCase("before")) {
      control_mode = 1;
      Serial.println("Mode switched to: BEFORE (Instant Motion)");
    } else if (command.equalsIgnoreCase("after")) {
      control_mode = 2;
      Serial.println("Mode switched to: AFTER (Smooth Motion)");
    } else if (command.equalsIgnoreCase("stop")) {
      control_mode = 0;
      Serial.println("Mode switched to: STOP (Motors Disabled)");
    }
  }

  // --- EKSEKUSI BERDASARKAN MODE YANG AKTIF ---
  
  // MODE 1: "BEFORE" (hb25_rosserial - Gerakan Instan)
  if (control_mode == 1) {
    motorControlL.moveAtSpeed(target_left_speed);
    motorControlR.moveAtSpeed(target_right_speed);
  }
  // MODE 2: "AFTER" (control_pwm - Gerakan Halus)
  else if (control_mode == 2) {
    unsigned long currentTime = millis();
    if (currentTime - lastUpdateTime >= update_interval) {
      lastUpdateTime = currentTime;
      
      if (current_left_speed < target_left_speed) current_left_speed = min(current_left_speed + speed_step, target_left_speed);
      else if (current_left_speed > target_left_speed) current_left_speed = max(current_left_speed - step_speed, target_left_speed);
      
      if (current_right_speed < target_right_speed) current_right_speed = min(current_right_speed + speed_step, target_right_speed);
      else if (current_right_speed > target_right_speed) current_right_speed = max(current_right_speed - step_speed, target_right_speed);
      
      motorControlL.moveAtSpeed(current_left_speed);
      motorControlR.moveAtSpeed(current_right_speed);
    }
  }
  // MODE 0: "STOP" (Kondisi Transisi)
  else {
    motorControlL.moveAtSpeed(0);
    motorControlR.moveAtSpeed(0);
    current_left_speed = 0;
    current_right_speed = 0;
  }
}
