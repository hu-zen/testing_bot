//=============================Motor Controll with Dynamic Direct Cycle PWM (DCP)===============================
// Versi 6.1 - Siklus PWM menyesuaikan secara dinamis dengan input joystick.
//============================================================================================================

#include <Servo.h>
#include <HB25MotorControl.h>
#include <ros.h>
#include <geometry_msgs/Twist.h>

//===========================================================================================
// --- BAGIAN KALIBRASI (UBAH NILAI DI SINI UNTUK MENGATUR "RASA" KONTROL) ---
//===========================================================================================
// Mengontrol kehalusan transisi.
// Angka lebih besar = siklus lebih halus dengan lebih banyak tahapan.
// Angka lebih kecil = siklus lebih tajam dengan lebih sedikit tahapan.
const int SMOOTHNESS_FACTOR = 10; 

// Jeda minimal antar tahapan PWM dalam MIKRODETIK.
const int MIN_STAGE_DELAY_US = 100;
//===========================================================================================


const byte controlPinL = 6;
const byte controlPinR = 7;

HB25MotorControl motorControlL(controlPinL);
HB25MotorControl motorControlR(controlPinR);

ros::NodeHandle nh;

// "Memori" untuk menyimpan kecepatan terakhir
int current_left_speed = 0;
int current_right_speed = 0;

void twistCallback(const geometry_msgs::Twist& twist_msg) {
  int linear_speed = (int)(twist_msg.linear.x * 300);
  int angular_speed = (int)(twist_msg.angular.z * 300);
  int left_speed = linear_speed - angular_speed;
  int right_speed = linear_speed + angular_speed;

  left_speed = constrain(left_speed, -500, 500);
  right_speed = constrain(right_speed, -500, 500);

  // --- LOGIKA DYNAMIC DIRECT CYCLE PWM (DCP) ---

  // Untuk Motor Kiri
  if (left_speed != current_left_speed) {
    // Jika ada perubahan perintah...
    int speed_diff = abs(left_speed - current_left_speed);
    int num_stages = max(1, speed_diff / SMOOTHNESS_FACTOR); // Hitung jumlah tahapan
    int step = (left_speed - current_left_speed) / num_stages;

    for (int i = 1; i <= num_stages; ++i) {
      int pwm_step = current_left_speed + (step * i);
      motorControlL.moveAtSpeed(pwm_step);
      delayMicroseconds(MIN_STAGE_DELAY_US);
    }
    motorControlL.moveAtSpeed(left_speed); // Pastikan mencapai target final
  }

  // Untuk Motor Kanan
  if (right_speed != current_right_speed) {
    int speed_diff = abs(right_speed - current_right_speed);
    int num_stages = max(1, speed_diff / SMOOTHNESS_FACTOR);
    int step = (right_speed - current_right_speed) / num_stages;

    for (int i = 1; i <= num_stages; ++i) {
      int pwm_step = current_right_speed + (step * i);
      motorControlR.moveAtSpeed(pwm_step);
      delayMicroseconds(MIN_STAGE_DELAY_US);
    }
    motorControlR.moveAtSpeed(right_speed);
  }

  // Update "memori" kecepatan dengan target yang baru
  current_left_speed = left_speed;
  current_right_speed = right_speed;
}

ros::Subscriber<geometry_msgs::Twist> sub("cmd_vel", &twistCallback);

void setup() {
  nh.getHardware()->setBaud(115200);
  nh.initNode();
  nh.subscribe(sub);
  motorControlL.begin();
  motorControlR.begin();
}

void loop() {
  nh.spinOnce();
}
