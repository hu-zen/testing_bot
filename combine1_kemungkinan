rostopic pub /mode_command std_msgs/String "data: 'after'" --once
rostopic pub /mode_command std_msgs/String "data: 'before'" --once
rostopic pub /mode_command std_msgs/String "data: 'stop'" --once
//=============================Motor Controll with Switchable Modes (ROS Method)======================
// Versi 8.0 - Final & Stabil. Mode diganti via ROS Topic untuk menghindari konflik serial.
//====================================================================================================

#include <Servo.h>
#include <HB25MotorControl.h>
#include <ros.h>
#include <geometry_msgs/Twist.h>
#include <std_msgs/String.h> // Tambahkan ini untuk menerima perintah mode

//===========================================================================================
// --- PENGATURAN PROGRAM ---
//===========================================================================================
// Mode Awal saat Arduino dinyalakan: 0=STOP, 1=BEFORE, 2=AFTER
int control_mode = 0; 
//===========================================================================================

// --- DEKLARASI MOTOR (PENTING: Harus di sini, di lingkup global) ---
const byte controlPinL = 6;
const byte controlPinR = 7;
HB25MotorControl motorControlL(controlPinL);
HB25MotorControl motorControlR(controlPinR);
// -----------------------------------------------------------------

ros::NodeHandle nh;

// --- Variabel untuk kontrol kecepatan ---
int target_left_speed = 0;
int target_right_speed = 0;
int current_left_speed = 0; // Hanya digunakan oleh mode "After"
int current_right_speed = 0; // Hanya digunakan oleh mode "After"

// --- Variabel untuk timing mode "After" ---
unsigned long lastUpdateTime = 0;
const int update_interval = 10;
const int speed_step = 2;


// --- Callback Function untuk menerima perintah kecepatan ---
void twistCallback(const geometry_msgs::Twist& twist_msg) {
  int linear_speed = (int)(twist_msg.linear.x * 300);
  int angular_speed = (int)(twist_msg.angular.z * 300);
  
  target_left_speed = linear_speed - angular_speed;
  target_right_speed = linear_speed + angular_speed;

  target_left_speed = constrain(target_left_speed, -500, 500);
  target_right_speed = constrain(target_right_speed, -500, 500);
}

// --- FUNGSI BARU: Callback untuk perintah ganti mode ---
void modeCallback(const std_msgs::String& msg) {
  String command = msg.data;
  if (command.equalsIgnoreCase("before")) {
    control_mode = 1;
    nh.loginfo("Mode switched to: BEFORE (Instant Motion)");
  } else if (command.equalsIgnoreCase("after")) {
    control_mode = 2;
    nh.loginfo("Mode switched to: AFTER (Smooth Motion)");
  } else if (command.equalsIgnoreCase("stop")) {
    control_mode = 0;
    nh.loginfo("Mode switched to: STOP (Motors Disabled)");
  }
}

ros::Subscriber<geometry_msgs::Twist> sub_vel("cmd_vel", &twistCallback);
// --- SUBSCRIBER BARU untuk ganti mode ---
ros::Subscriber<std_msgs::String> sub_mode("mode_command", &modeCallback);

void setup() {
  nh.getHardware()->setBaud(115200);
  nh.initNode();
  nh.subscribe(sub_vel);
  nh.subscribe(sub_mode); // Daftarkan subscriber baru

  motorControlL.begin();
  motorControlR.begin();
  
  delay(500); // Jeda singkat untuk memastikan semua siap
  nh.loginfo("Switchable motor controller ready.");
}

void loop() {
  nh.spinOnce();
  
  // --- EKSEKUSI BERDASARKAN MODE YANG AKTIF ---
  
  // MODE 1: "BEFORE" (hb25_rosserial - Gerakan Instan)
  if (control_mode == 1) {
    motorControlL.moveAtSpeed(target_left_speed);
    motorControlR.moveAtSpeed(target_right_speed);
  }
  // MODE 2: "AFTER" (control_pwm - Gerakan Halus)
  else if (control_mode == 2) {
    unsigned long currentTime = millis();
    if (currentTime - lastUpdateTime >= update_interval) {
      lastUpdateTime = currentTime;
      
      if (current_left_speed < target_left_speed) current_left_speed = min(current_left_speed + speed_step, target_left_speed);
      else if (current_left_speed > target_left_speed) current_left_speed = max(current_left_speed - speed_step, target_left_speed);
      
      if (current_right_speed < target_right_speed) current_right_speed = min(current_right_speed + speed_step, target_right_speed);
      else if (current_right_speed > target_right_speed) current_right_speed = max(current_right_speed - speed_step, target_right_speed);
      
      motorControlL.moveAtSpeed(current_left_speed);
      motorControlR.moveAtSpeed(current_right_speed);
    }
  }
  // MODE 0: "STOP" (Kondisi Transisi)
  else {
    motorControlL.moveAtSpeed(0);
    motorControlR.moveAtSpeed(0);
    current_left_speed = 0;
    current_right_speed = 0;
  }
}
